{
  "hash": "828c450cec75e505cec8359d82fe9698",
  "result": {
    "markdown": "---\ntitle: \"Week 2 Challenge\"\nauthor: \"Steve O'Neill\"\ndescription: \"Describing the Basic Structure of a Network\"\ndate: \"02/22/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: false\n    code-copy: true\n    code-tools: true\n# editor: visual\ndf-paged: true\ncategories: \n  - challenge_2\n  - instructions\n  # - railroads\n  # - faostat\n  # - wildbirds\n---\n\n\n\n\n## Challenge Overview\n\n*Describe the basic structure of a network following the steps in tutorial of week 2, this time using a dataset of your choice: for instance, you could use Marriages in Game of Thrones or Like/Dislike from week 1.*\n\n*Another more complex option is the newly added dataset of the US input-output table of direct requirements by industry, availabe in the Bureau of Economic Analysis. Input-output tables show the economic transactions between industries of an economy and thus can be understood as a directed adjacency matrix. Data is provided in the form of an `XLSX` file, so using `read_xlsx` from package `readxl` is recommended, including the `sheet` as an argument (`2012` for instance).*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequirements_2007 <- read_xlsx(\"_data/got/US_input_output_table_2007_and_2012.xlsx\", sheet = 4, skip = 4)\nrequirements_2012 <- read_xlsx(\"_data/got/US_input_output_table_2007_and_2012.xlsx\", sheet = 3, skip = 4)\n```\n:::\n\n\n*Identify and describe content of nodes and links, and identify format of data set (i.e., matrix or edgelist, directed or not, weighted or not), and whether attribute data are present. Be sure to provide information about network size (e.g., information obtained from network description using week 1 network basic tutorial commands.)*\n\nFirst, a look at the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(requirements_2007)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 407\n  Code   Commo…¹ 1111A…² 1111B…³ 11120…⁴ 11130…⁵ 11140…⁶ 11190…⁷ 11212…⁸ 1121A…⁹\n  <chr>  <chr>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 1111A0 Oilsee… 0.0524  0.00135 2.37e-4 0       0       4.9 e-6  0       0     \n2 1111B0 Grain … 0       0.0663  0       0       0       1.53e-2  0.0450  0.0707\n3 111200 Vegeta… 0       0       3.03e-2 1.66e-4 0       0        0       0     \n4 111300 Fruit … 0       0       0       1.15e-2 0       0        0       0     \n5 111400 Greenh… 0       0       0       0       1.46e-1 0        0       0     \n6 111900 Other … 0.00636 0.00714 0       0       2.52e-5 2.69e-2  0.0247  0.0207\n# … with 397 more variables: `112300` <dbl>, `112A00` <dbl>, `113000` <dbl>,\n#   `114000` <dbl>, `115000` <dbl>, `211000` <dbl>, `212100` <dbl>,\n#   `212230` <dbl>, `2122A0` <dbl>, `212310` <dbl>, `2123A0` <dbl>,\n#   `213111` <dbl>, `21311A` <dbl>, `221100` <dbl>, `221200` <dbl>,\n#   `221300` <dbl>, `233210` <dbl>, `233262` <dbl>, `230301` <dbl>,\n#   `230302` <dbl>, `2332A0` <dbl>, `233412` <dbl>, `2334A0` <dbl>,\n#   `233230` <dbl>, `2332D0` <dbl>, `233240` <dbl>, `233411` <dbl>, …\n```\n:::\n:::\n\n\nThe dataset is not exactly ready for import. There are mismatching columns and 'codes'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(requirements_2007)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 409 407\n```\n:::\n:::\n\n\nThis code attempts to resolve that using the `intersect()` between the values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the column names and values in the \"Code\" column\ncols <- colnames(requirements_2007)\ncode <- requirements_2007$Code\n\ncodes_intersect <- intersect(cols, code)\n\nrequirements_adjacency_full <- requirements_2007 %>% filter(Code %in% codes_intersect) %>% select('Code', 'Commodity Description', all_of(codes_intersect)) \n\nrequirements_adjacency_matrix <- as.matrix(requirements_2007 %>% filter(Code %in% codes_intersect) %>% select(all_of(codes_intersect)))\n\n#Get dimensions of matrix - is it 'square'?\ndim(requirements_adjacency_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 401 401\n```\n:::\n:::\n\n\nThe resulting data is 'square' and only includes codes found in both the 'Code' column and column names. Now that it is in matrix format using `as.matrix`, I can give it to igraph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequirements_2007_matrix.ig <- graph_from_adjacency_matrix(requirements_adjacency_matrix, weighted = TRUE,\n                                 mode = \"directed\")\nvcount(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 401\n```\n:::\n\n```{.r .cell-code}\necount(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51860\n```\n:::\n:::\n\n\nThe igraph object has 401 vertices and 51860 edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_bipartite(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_directed(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_weighted(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIt's not bipartite, yet it is directed (like I specified) and weighted (like I specified). The directions are the flow of commodities from industry to industry, and the weights are dollar amounts in millions USD.\n\nBecause it's from a numeric matrix, just `name` and `weight` are included.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Just names and weight\nvertex_attr_names(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nedge_attr_names(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"weight\"\n```\n:::\n:::\n\n\nHang on. There are some negative edges?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Wait. Some negative values?\nsummary(E(requirements_2007_matrix.ig)$weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \n-0.0045264  0.0001213  0.0006157  0.0041073  0.0024217  0.6891621 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify edges with negative weights\nnegative_edges <- which(E(requirements_2007_matrix.ig)$weight < 0)\n\n# print the edges with negative weights\nE(requirements_2007_matrix.ig)[negative_edges]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 8/51860 edges from c781ed9 (vertex names):\n[1] 1111A0->S00600 1111B0->S00600 31151A->S00600 5241XX->334111 5241XX->312200\n[6] 5241XX->5191A0 5241XX->522A00 5241XX->52A000\n```\n:::\n:::\n\n\nOnly 8 negative edges. I want to remove them since they make finding distances impossible later. At just 8 edges of a low magnitude, I am not sure if they will make a difference either way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequirements_2007_matrix.ig <- delete_edges(requirements_2007_matrix.ig, negative_edges)\n```\n:::\n\n\nAs expected, 8 less than before.\n\n\n::: {.cell}\n\n```{.r .cell-code}\necount(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51852\n```\n:::\n:::\n\n\nI want to bring in the descriptions in next:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncommodity_names <- setNames(requirements_adjacency_full$`Commodity Description`, requirements_adjacency_full$Code)\n\n# Set the vertex attribute with the industry names\nV(requirements_2007_matrix.ig)$commodity_name <- commodity_names[as.character(V(requirements_2007_matrix.ig)$name)]\n```\n:::\n\n\nNow they are in the igprah object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(V(requirements_2007_matrix.ig)$commodity_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Oilseed farming\"                                 \n[2] \"Grain farming\"                                   \n[3] \"Vegetable and melon farming\"                     \n[4] \"Fruit and tree nut farming\"                      \n[5] \"Greenhouse, nursery, and floriculture production\"\n[6] \"Other crop farming\"                              \n```\n:::\n:::\n\n\nReally, though, I want the vertexes to be named with those descriptions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(requirements_2007_matrix.ig)$name <- V(requirements_2007_matrix.ig)$commodity_name\n```\n:::\n\n\nPlotting for the first time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output-display}\n![](Week2Challenge_ONeill_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nA zoomed in version is better:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\n# Set x and y axis limits\n\nxlim <- c(-1, 0)\nylim <- c(-1, 0)\n\n# Plot the graph with arrows and node labels\nplot(requirements_2007_matrix.ig, xlim=xlim, ylim=ylim)\n```\n\n::: {.cell-output-display}\n![](Week2Challenge_ONeill_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n### Dyad Census\n\n20039 mutual, 31426 asymmetric, and 38735 empty dyads:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::dyad.census(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 10039\n\n$asym\n[1] 31426\n\n$null\n[1] 38735\n```\n:::\n:::\n\n\n### Triad Census\n\nThe output of this function is not readily interpretable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad_2007 <- igraph::triad_census(requirements_2007_matrix.ig)\ntriad_2007\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2342075 2118395  267294 2051609  185533  255376   61575  974775  609733\n[10]    8020  128794   64031  915196  111459  364562  208173\n```\n:::\n:::\n\n\nTo help with that, I found a table describing the types of triad connections. The source from this table is [here](http://www.analytictech.com/ucinet/help/hs4335.htm):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad_types <- c(\n'003' = 'A,B,C, empty triad.',\n'012' = 'A->B, C, triad with a single directed edge.',\n'102' = 'A<->B, C, triad with a reciprocated connection between two vertices.',\n'021D' = 'A<-B->C, triadic out-star.',\n'021U' = 'A->B<-C triadic in-star.',\n'021C' = 'A->B->C, directed line.',\n'111D' = 'A<->B<-C.',\n'111U' = 'A<->B->C.',\n'030T' = 'A->B<-C, A->C.',\n'030C' = 'A<-B<-C, A->C.',\n'201' = 'A<->B<->C.',\n'120D' = 'A<-B->C, A<->C.',\n'120U' = 'A->B<-C, A<->C.',\n'120C' = 'A->B->C, A<->C.',\n'210' = 'A->B<->C, A<->C.',\n'300' = 'A<->B<->C, A<->C,  complete triad.'\n)\n```\n:::\n\n\nNow to combine those with the data,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(triad_2007) <- triad_types\ntriad_2007 <- data.frame(triad_2007)\ntriad_2007$triad_type <- row.names(triad_2007)\n```\n:::\n\n\nThen to plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(triad_2007, aes(x = triad_type, y = triad_2007)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +\n  labs(x = \"Triad Types\", y = \"Frequency\", \n       title = \"Frequency of Triad Types in Triad_2007 Data Frame\")\n```\n\n::: {.cell-output-display}\n![](Week2Challenge_ONeill_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## Global and Local Transitivity or Clustering\n\nFirst, the transitivity overall:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransitivity(requirements_2007_matrix.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6516905\n```\n:::\n:::\n\n\nAnd now, the comparison between the global and local clustering coefficients, respectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get global clustering coefficient: igraph\ntransitivity(requirements_2007_matrix.ig, type=\"global\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6516905\n```\n:::\n\n```{.r .cell-code}\n#get average local clustering coefficient: igraph\ntransitivity(requirements_2007_matrix.ig, type=\"average\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7845561\n```\n:::\n:::\n\n\n## Path Length and Component Structure\n\nHere is the distance between \"Automobile manufacturing\" and \"Truck trailer manufacturing\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistances(requirements_2007_matrix.ig,\"Automobile manufacturing\", \"Truck trailer manufacturing\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                         Truck trailer manufacturing\nAutomobile manufacturing                     2.6e-06\n```\n:::\n:::\n\n\nAnd the overall average path length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage.path.length(requirements_2007_matrix.ig,directed=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0007344345\n```\n:::\n:::\n\n\nThis shows we have an unconnected graph with two isolates and, technically, 3 components (one of them being giant)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(igraph::components(requirements_2007_matrix.ig))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"membership\" \"csize\"      \"no\"        \n```\n:::\n\n```{.r .cell-code}\nigraph::components(requirements_2007_matrix.ig)$no #Number of components\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nigraph::components(requirements_2007_matrix.ig)$csize #Size of each component\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 399   1   1\n```\n:::\n:::\n\n\n### Postscript: NAICS Codes\n\nJust including this here because I want to use it in a later assignment.\n\nThe second sheet includes a look-up table of NAICS codes. Unfortunately, the 'child' NAICS codes do not always begin with the same numbers as the 'parent' category NAICS codes. For example, **Durable Goods 33DG** contains NAICS code 3211 (Sawmills and wood preservation).\n\nI want to use the parent NAICS codes to make a legible graph with a reasonable number of nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Get NAICS codes\nnaics <- read_xlsx(\"_data/got/US_input_output_table_2007_and_2012.xlsx\", sheet = 2, skip = 4)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nNew names:\n• `` -> `...5`\n```\n:::\n:::\n\n\nIn other words, I just want these sectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnaics %>% \n  filter(!str_detect(Summary, \"\\\\d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 7\n   Sector Summary                             U.Sum…¹ Detail ...5  Notes Relat…²\n   <chr>  <chr>                               <chr>   <chr>  <chr> <chr> <chr>  \n 1 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    <NA>   <NA>  <NA>  <NA>   \n 2 21     MINING                              <NA>    <NA>   <NA>  <NA>  <NA>   \n 3 22     UTILITIES                           <NA>    <NA>   <NA>  <NA>  <NA>   \n 4 23     CONSTRUCTION                        <NA>    <NA>   <NA>  <NA>  <NA>   \n 5 33DG   DURABLE GOODS                       <NA>    <NA>   <NA>  <NA>  <NA>   \n 6 31ND   NONDURABLE GOODS                    <NA>    <NA>   <NA>  <NA>  <NA>   \n 7 42     WHOLESALE TRADE                     <NA>    <NA>   <NA>  <NA>  <NA>   \n 8 44RT   RETAIL TRADE                        <NA>    <NA>   <NA>  <NA>  <NA>   \n 9 48TW   TRANSPORTATION AND WAREHOUSING, EX… <NA>    <NA>   <NA>  <NA>  <NA>   \n10 51     INFORMATION                         <NA>    <NA>   <NA>  <NA>  <NA>   \n# … with 22 more rows, and abbreviated variable names ¹​U.Summary,\n#   ²​`Related 2012 NAICS Codes`\n```\n:::\n:::\n\n\nTo get there, I'll use fill(). After this, every value in `Related 2012 NAICS Codes` will have one of the \\~30 NAICS sectors accompanying it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Remove any value in `Summary` if it has even one number\nnaics <- naics %>% mutate(Summary = case_when(\n  (str_detect(Summary, \"\\\\d\")) ~ NA,\n  TRUE ~ Summary))\n\nnaics <- naics %>% fill(Sector, Summary)\n\nnaics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,026 × 7\n   Sector Summary                             U.Sum…¹ Detail ...5  Notes Relat…²\n   <chr>  <chr>                               <chr>   <chr>  <chr> <chr> <chr>  \n 1 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    <NA>   <NA>  <NA>  <NA>   \n 2 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    <NA>   <NA>  <NA>  <NA>   \n 3 11     AGRICULTURE, FORESTRY, FISHING, AN… Farms   <NA>   <NA>  <NA>  <NA>   \n 4 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    <NA>   <NA>  <NA>  <NA>   \n 5 11     AGRICULTURE, FORESTRY, FISHING, AN… 111     Crop … <NA>  <NA>  <NA>   \n 6 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    <NA>   <NA>  <NA>  <NA>   \n 7 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    1111A0 Oils… <NA>  11111-2\n 8 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    1111B0 Grai… <NA>  11113-…\n 9 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    111200 Vege… <NA>  1112   \n10 11     AGRICULTURE, FORESTRY, FISHING, AN… <NA>    111300 Frui… <NA>  1113   \n# … with 1,016 more rows, and abbreviated variable names ¹​U.Summary,\n#   ²​`Related 2012 NAICS Codes`\n```\n:::\n:::\n\n\nMore to come on this next assignment.\n",
    "supporting": [
      "Week2Challenge_ONeill_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}