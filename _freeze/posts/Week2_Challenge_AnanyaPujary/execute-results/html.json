{
  "hash": "839160b05379b1f8ba6272c55c040e8a",
  "result": {
    "markdown": "---\ntitle: \"Week 2 Challenge\"\nauthor: \"Ananya Pujary\"\ndescription: \"Describing the Basic Structure of a Network\"\ndate: \"02/22/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n# editor: visual\ncategories: \n  - challenge_2\n  - Ananya Pujary\n  # - railroads\n  # - faostat\n  # - wildbirds\n---\n\n\n\n\n## Challenge Overview\n\nDescribe the basic structure of a network following the steps in tutorial of week 2, this time using a dataset of your choice: for instance, you could use Marriages in Game of Thrones or Like/Dislike from week 1. \n\nAnother more complex option is the newly added dataset of the US input-output table of direct requirements by industry, available in the Bureau of Economic Analysis. Input-output tables show the economic transactions between industries of an economy and thus can be understood as a directed adjacency matrix. Data is provided in the form of an `XLSX` file, so using `read_xlsx` from package `readxl` is recommended, including the `sheet` as an argument (`2012` for instance).\n\nIdentify and describe content of nodes and links, and identify format of data set (i.e., matrix or edgelist, directed or not, weighted or not), and whether attribute data are present. Be sure to provide information about network size (e.g., information obtained from network description using week 1 network basic tutorial commands.)\n\n\n## Describe the Network Data\n\n### Listing objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# listing all objects\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n\nI'll be working with the Game of Thrones like-dislike dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_marriages<-read_csv(\"../posts/_data/got/got_marriages.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 255 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): From, To, Type, Notes, Generation\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ngot_marriages\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 255 × 5\n   From      To        Type    Notes  Generation\n   <chr>     <chr>     <chr>   <chr>  <chr>     \n 1 Targaryen Stark     Married R+L=J  Current   \n 2 Baratheon Martell   Engaged died   Current   \n 3 Baratheon Stark     Engaged broken Current   \n 4 Martell   Essos     Married <NA>   Current   \n 5 Martell   Reach     Affair  <NA>   Current   \n 6 Martell   Essos     Affair  <NA>   Current   \n 7 Martell   Essos     Affair  <NA>   Current   \n 8 Martell   Septa     Affair  <NA>   Current   \n 9 Martell   Dorne     Affair  <NA>   Current   \n10 Martell   Targaryen Married <NA>   Current   \n# … with 245 more rows\n```\n:::\n\n```{.r .cell-code}\ngot_marriages.ig <-graph_from_data_frame(got_marriages, directed = FALSE)\n```\n:::\n\n\n### Network Size and Features\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# network size\nvcount(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\necount(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 255\n```\n:::\n\n```{.r .cell-code}\n# network features\nis_directed(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_bipartite(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_weighted(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThis network has 20 vertices and 255 edges. It is not directed, not bipartite, and not weighted.\n\n### Network Attributes\n\nListing the vertex and edge attributes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_attr_names(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nedge_attr_names(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Type\"       \"Notes\"      \"Generation\"\n```\n:::\n:::\n\n\n## Dyad and Triad Census\n\nNow, trying a dyad census to figure out the number of dyads that have reciprocal, asymmetric, and absent relationships:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::dyad.census(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 60\n\n$asym\n[1] 0\n\n$null\n[1] 130\n```\n:::\n:::\n\n\nIn this network, there are 60 mutual, 0 asymmetric, and 130 absent relationships. This is interesting since it maps marriages connections in the GOT universe, indicating that a lot of characters aren't married, and there are no asymmetric ties because marriage is a mutual partnership.\n\n\nNow doing a triad census:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad_census(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in triad_census(got_marriages.ig): At core/misc/motifs.c:1165 : Triad\ncensus called on an undirected graph.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 625   0 227   0   0   0   0   0   0   0 228   0   0   0   0  60\n```\n:::\n:::\n\n\n\n## Global and Local Transitivity or Clustering\n\nCompute global transitivity using `transitivity` on `igraph` or `gtrans` on `statnet` and local transitivity of specific nodes of your choice, in addition to the average clustering coefficient. What is the distribution of node degree and how does it compare with the distribution of local transitivity?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# global clustering\nigraph::transitivity(got_marriages.ig, type=\"global\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4411765\n```\n:::\n\n```{.r .cell-code}\n# local clustering\ntransitivity(got_marriages.ig, type=\"average\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5478074\n```\n:::\n\n```{.r .cell-code}\n# listing vertices I'm interested in\nV(got_marriages.ig)[V(got_marriages.ig)$name == \"Lannister\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 1/20 vertex, named, from 7c2b352:\n[1] Lannister\n```\n:::\n\n```{.r .cell-code}\n# checking ego network transitivity\nigraph::transitivity(got_marriages.ig, type=\"local\", vids=V(got_marriages.ig)$name) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.3636364 0.4181818 0.4000000 0.7000000 1.0000000 0.3636364 0.1666667\n [8] 0.5714286 0.6666667 0.4166667 0.4666667 0.6666667 0.5000000 0.2888889\n[15] 0.5714286 0.7000000 0.6000000       NaN 1.0000000       NaN\n```\n:::\n\n```{.r .cell-code}\nigraph::transitivity(got_marriages.ig, type=\"local\", vids=V(got_marriages.ig)[c(\"Targaryen\",\"Baratheon\", \"Lannister\")]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3636364 0.4181818 0.7000000\n```\n:::\n\n```{.r .cell-code}\n# trans.vector <- transitivity(like_dislike.ig, type = \"local\")\n# trans.vector[V(like_dislike.ig)$name == \"Jon Snow\"]\n```\n:::\n\n\nThe global transitivity is 0.4411765 and the local transitivity is 0.5478074 The local transitivity of \"Targaryen\" is 0.3636364, 0.4181818 for \"Baratheon\", and 0.7000000 for \"Lannister\". Thus, Lannister seems to be the family with the most marriages when compared to Targaryen and Baratheon.\n\n\n## Path Length and Component Structure \n\nCan you compute the average path length and the _diameter_ of the network? Can you find the component structure of the network and identify the cluster membership of each node?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# average path length\naverage.path.length(got_marriages.ig,directed=F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.9\n```\n:::\n\n```{.r .cell-code}\n# diameter of network\ndiameter(got_marriages.ig, directed=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n# looking at the network component structure\nnames(igraph::components(got_marriages.ig))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"membership\" \"csize\"      \"no\"        \n```\n:::\n\n```{.r .cell-code}\n## number of components\nigraph::components(got_marriages.ig)$no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n## size of each component\nigraph::components(got_marriages.ig)$csize\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\n# calculate distance using unweighted edges\ndistances(got_marriages.ig,\"Lannister\",\"North\", weights=NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          North\nLannister     2\n```\n:::\n:::\n\n\nThe average path length is 1.9 and the diameter is 4, which indicates that it is a relatively small network. It has one component with 20 nodes, so it is very connected. The distance between North and Lannister is 2, which is around the average path length.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plotting the network\nE(got_marriages.ig)$color <- colorRampPalette(c(\"yellow\", \"blue\"))(11)[E(got_marriages.ig)$weight + 6]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in length(eattrs[[name]]) <- ec: length of NULL cannot be changed\n```\n:::\n\n```{.r .cell-code}\nV(got_marriages.ig)$color[grep(\"Lannister\", V(got_marriages.ig)$name)] <- \"red\"\n\nplot(got_marriages.ig)\n```\n\n::: {.cell-output-display}\n![](Week2_Challenge_AnanyaPujary_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Week2_Challenge_AnanyaPujary_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}