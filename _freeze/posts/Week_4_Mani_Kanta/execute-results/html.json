{
  "hash": "a2a5e198bc874e657dfb192e12511b9b",
  "result": {
    "markdown": "---\ntitle: \"Week 4 Challenge Instructions\"\nauthor: \"Mani_Kanta_Gogula\"\ndescription: \"Centrality of a Network\"\ndate: \"03/06/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n# editor: visual\ncategories: \n  - challenge_4\n  - instructions\n  # - railroads\n  # - faostat\n  # - wildbirds\n---\n\n\n\n\n## Challenge Overview\n\nDescribe the many measures of centrality of at least one network of your choice.\n\n## Describe the Network Data\n\nIf you have not done it before, always start by evaluating the basic structure of the network (number of edges and vertices, dyad and triad census, etc.). Create a data frame `nodes` with the corresponding local attributes such as degree or local transitivity.\n\n## Centrality\n\nCompute at least one measure of centrality for each node, adding them as attributes to `nodes` in the form of extra columns: eigencentrality, betweenness, closeness, etc. Compute the distribution of at least one of those measures. What do we learn from comparing these measures of centrality with an equivalent random network (i.e. with the same number of edges and vertices)?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'readr' was built under R version 4.1.3\n```\n:::\n\n```{.r .cell-code}\ngot_marriages <- read_csv(\"_data/got/got_marriages.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 255 Columns: 5\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (5): From, To, Type, Notes, Generation\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nhead(got_marriages)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n  From      To      Type    Notes  Generation\n  <chr>     <chr>   <chr>   <chr>  <chr>     \n1 Targaryen Stark   Married R+L=J  Current   \n2 Baratheon Martell Engaged died   Current   \n3 Baratheon Stark   Engaged broken Current   \n4 Martell   Essos   Married <NA>   Current   \n5 Martell   Reach   Affair  <NA>   Current   \n6 Martell   Essos   Affair  <NA>   Current   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the required package\nlibrary(igraph)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'igraph' was built under R version 4.1.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'igraph'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:base':\n\n    union\n```\n:::\n\n```{.r .cell-code}\n# Create the network from the dataset\nnetwork <- graph.data.frame(got_marriages, directed = FALSE)\n\n# Basic structure of the network\nnum_edges <- ecount(network)\nnum_vertices <- vcount(network)\n\n# Dyad and triad census\ndyads <- dyad_census(network)\ntriads <- triad_census(network)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in triad_census(network): At core/misc/motifs.c:1165 : Triad census\ncalled on an undirected graph.\n```\n:::\n\n```{.r .cell-code}\n# Create the nodes data frame with local attributes\nnodes <- data.frame(\n  vertex = V(network)$name,  # Assuming the vertices have a 'name' attribute\n  degree = degree(network),\n  transitivity = transitivity(network, type = \"local\")\n)\n\n# Print the basic network structure\ncat(\"Number of edges:\", num_edges, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of edges: 255 \n```\n:::\n\n```{.r .cell-code}\ncat(\"Number of vertices:\", num_vertices, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of vertices: 20 \n```\n:::\n\n```{.r .cell-code}\nprint(dyads)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 60\n\n$asym\n[1] 0\n\n$null\n[1] 130\n```\n:::\n\n```{.r .cell-code}\nprint(triads)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 625   0 227   0   0   0   0   0   0   0 228   0   0   0   0  60\n```\n:::\n\n```{.r .cell-code}\n# Print the nodes data frame\nprint(nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 vertex degree transitivity\nTargaryen     Targaryen     85    0.3636364\nBaratheon     Baratheon     17    0.4181818\nMartell         Martell     12    0.4000000\nLannister     Lannister     28    0.7000000\nTyrell           Tyrell     12    1.0000000\nReach             Reach     49    0.3636364\nNorth             North     46    0.1666667\nRiverlands   Riverlands     39    0.5714286\nWesterlands Westerlands     31    0.6666667\nStark             Stark     34    0.4166667\nVale               Vale     37    0.4666667\nArryn             Arryn     10    0.6666667\nTully             Tully      5    0.5000000\nFrey               Frey     51    0.2888889\nCrownlands   Crownlands     22    0.5714286\nStormlands   Stormlands     11    0.7000000\nEssos             Essos     15    0.6000000\nSepta             Septa      1          NaN\nDorne             Dorne      4    1.0000000\nBeyond Wall Beyond Wall      1          NaN\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nin_net <- centr_degree(network, loops = FALSE, mode = \"in\")\nin_net\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 47 17 12 20 12 25 22 33 25 26 17  8  5 47 22 11 15  1  4  1\n\n$centralization\n[1] 1.666667\n\n$theoretical_max\n[1] 342\n```\n:::\n\n```{.r .cell-code}\nout_net <- centr_degree(network, loops = FALSE, mode = \"out\")\nout_net\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 47 17 12 20 12 25 22 33 25 26 17  8  5 47 22 11 15  1  4  1\n\n$centralization\n[1] 1.666667\n\n$theoretical_max\n[1] 342\n```\n:::\n\n```{.r .cell-code}\nnet_total <- centr_degree(network, loops = FALSE, mode = \"total\")\nnet_total\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 47 17 12 20 12 25 22 33 25 26 17  8  5 47 22 11 15  1  4  1\n\n$centralization\n[1] 1.666667\n\n$theoretical_max\n[1] 342\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neigen <- eigen_centrality(network)$vector\n\nbetweeness <- igraph::betweenness(network, directed = F)\n\nclose <- igraph::closeness(network, mode = \"out\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the distribution of one centrality measure (e.g., eigencentrality)\neigen_dist <- table(nodes$eigen)\n\n# Print the distribution of eigencentrality\nprint(eigen_dist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n< table of extent 0 >\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}