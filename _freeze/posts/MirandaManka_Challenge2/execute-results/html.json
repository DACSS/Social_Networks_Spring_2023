{
  "hash": "1231cd28ef99bbffb9db7b894554eeb2",
  "result": {
    "markdown": "---\ntitle: \"Week 2 Challenge - GOT Marriages - Census, Transitivity, etc\"\nauthor: \"Miranda Manka\"\ndescription: \"Describing the Basic Structure of a Network\"\ndate: \"03/22/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories: \n  - challenge_2\n  - Miranda Manka\n---\n\n\n\n\n## Challenge Overview\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_marriages = read_csv(\"_data/got/got_marriages.csv\", show_col_types = FALSE)\ngot_marriages\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 255 × 5\n   From      To        Type    Notes  Generation\n   <chr>     <chr>     <chr>   <chr>  <chr>     \n 1 Targaryen Stark     Married R+L=J  Current   \n 2 Baratheon Martell   Engaged died   Current   \n 3 Baratheon Stark     Engaged broken Current   \n 4 Martell   Essos     Married <NA>   Current   \n 5 Martell   Reach     Affair  <NA>   Current   \n 6 Martell   Essos     Affair  <NA>   Current   \n 7 Martell   Essos     Affair  <NA>   Current   \n 8 Martell   Septa     Affair  <NA>   Current   \n 9 Martell   Dorne     Affair  <NA>   Current   \n10 Martell   Targaryen Married <NA>   Current   \n# … with 245 more rows\n```\n:::\n:::\n\n\n## Describe the Network Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_marriages.ig = graph_from_data_frame(got_marriages, directed = FALSE) #directed = false because with relationships, if a is married to b then b is also married to a\ngot_marriages.ig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH a8a852e UN-- 20 255 -- \n+ attr: name (v/c), Type (e/c), Notes (e/c), Generation (e/c)\n+ edges from a8a852e (vertex names):\n [1] Targaryen--Stark       Baratheon--Martell     Baratheon--Stark      \n [4] Martell  --Essos       Martell  --Reach       Martell  --Essos      \n [7] Martell  --Essos       Martell  --Septa       Martell  --Dorne      \n[10] Targaryen--Martell     Targaryen--Essos       Targaryen--Essos      \n[13] Baratheon--Lannister   Baratheon--Vale        Baratheon--Riverlands \n[16] Baratheon--Crownlands  Baratheon--Reach       Baratheon--Westerlands\n[19] Baratheon--Crownlands  Lannister--Lannister   Baratheon--Reach      \n[22] Baratheon--Tyrell      Tyrell   --Reach       Tyrell   --Reach      \n+ ... omitted several edges\n```\n:::\n\n```{.r .cell-code}\nvcount(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\necount(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 255\n```\n:::\n\n```{.r .cell-code}\nis_bipartite(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_directed(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_weighted(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nvertex_attr_names(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nedge_attr_names(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Type\"       \"Notes\"      \"Generation\"\n```\n:::\n\n```{.r .cell-code}\ntable(got_marriages$Type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n Affair Engaged Married \n     36       2     217 \n```\n:::\n\n```{.r .cell-code}\nplot(got_marriages.ig)\n```\n\n::: {.cell-output-display}\n![](MirandaManka_Challenge2_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Dyad and Triad Census\n\nNow try a full dyad census. This gives us the number of dyads where the relationship is:\n\n- Reciprocal (mutual), or `mut`\n- Asymmetric (non-mutual), or `asym`, and\n- Absent, or `null`\n\nNow use `triad.census` in order to do a triad census.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndyad_got = dyad.census(got_marriages.ig)\ndyad_got\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 60\n\n$asym\n[1] 0\n\n$null\n[1] 130\n```\n:::\n\n```{.r .cell-code}\ntriad_got = triad.census(got_marriages.ig)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in triad.census(got_marriages.ig): At core/misc/motifs.c:1165 : Triad\ncensus called on an undirected graph.\n```\n:::\n\n```{.r .cell-code}\ntriad_got\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 625   0 227   0   0   0   0   0   0   0 228   0   0   0   0  60\n```\n:::\n:::\n\n\n## Global and Local Transitivity or Clustering\n\nCompute global transitivity using `transitivity` on `igraph` or `gtrans` on `statnet` and local transitivity of specific nodes of your choice, in addition to the average clustering coefficient. What is the distribution of node degree and how does it compare with the distribution of local transitivity?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_transitivity = transitivity(got_marriages.ig, type = 'global')\nglobal_transitivity\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4411765\n```\n:::\n\n```{.r .cell-code}\nV(got_marriages.ig)$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Targaryen\"   \"Baratheon\"   \"Martell\"     \"Lannister\"   \"Tyrell\"     \n [6] \"Reach\"       \"North\"       \"Riverlands\"  \"Westerlands\" \"Stark\"      \n[11] \"Vale\"        \"Arryn\"       \"Tully\"       \"Frey\"        \"Crownlands\" \n[16] \"Stormlands\"  \"Essos\"       \"Septa\"       \"Dorne\"       \"Beyond Wall\"\n```\n:::\n\n```{.r .cell-code}\nV(got_marriages.ig)[c(\"Targaryen\", \"Baratheon\", \"Martell\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 3/20 vertices, named, from a8a852e:\n[1] Targaryen Baratheon Martell  \n```\n:::\n\n```{.r .cell-code}\nlocal_transitivity = transitivity(got_marriages.ig, type=\"local\", vids=V(got_marriages.ig)[c(\"Targaryen\", \"Baratheon\", \"Martell\")]) \nlocal_transitivity\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3636364 0.4181818 0.4000000\n```\n:::\n\n```{.r .cell-code}\navg_cluster_coef = transitivity(got_marriages.ig, type = 'average')\navg_cluster_coef\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5478074\n```\n:::\n:::\n\n\n## Path Length and Component Structure \n\nCan you compute the average path length and the _diameter_ of the network? Can you find the component structure of the network and identify the cluster membership of each node?\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_path_length = average.path.length(got_marriages.ig, directed=F)\navg_path_length\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.9\n```\n:::\n\n```{.r .cell-code}\nnames(igraph::components(got_marriages.ig))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"membership\" \"csize\"      \"no\"        \n```\n:::\n\n```{.r .cell-code}\nno_compon = igraph::components(got_marriages.ig)$no\nno_compon\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nsize_compon = igraph::components(got_marriages.ig)$csize\nsize_compon\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n",
    "supporting": [
      "MirandaManka_Challenge2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}