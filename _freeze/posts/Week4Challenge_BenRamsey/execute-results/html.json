{
  "hash": "cb0cd8802e39c582fd7f0cf086f68b85",
  "result": {
    "markdown": "---\ntitle: \"Week 4 Challenge\"\nauthor: \"Ben Ramsey\"\ndescription: \"Centrality of a Network\"\ndate: \"03/06/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n# editor: visual\ncategories: \n  - challenge_4\n  # - railroads\n  # - faostat\n  # - wildbirds\n---\n\n\n\n\n## Challenge Overview\n\nDescribe the many measures of centrality of at least one network of your choice.\n\n## Describe the Network Data\n\nIf you have not done it before, always start by evaluating the basic structure of the network (number of edges and vertices, dyad and triad census, etc.). Create a data frame `nodes` with the corresponding local attributes such as degree or local transitivity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclimate <- read.csv(\"_data/climate0205-allop.csv\", sep =  \";\") %>% subset(select = -c(X))\nclimate.ig <- graph_from_adjacency_matrix(as.matrix(climate), weighted = TRUE, mode = \"directed\", add.rownames = TRUE)\nclimate.net <- as.network(as.matrix(climate), directed = TRUE, weighted = TRUE)\nprint(climate.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 34 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 291 \n    missing edges= 0 \n    non-missing edges= 291 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n\n```{.r .cell-code}\ndyad.census(climate.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Mut Asym Null\n[1,]  65  161  335\n```\n:::\n\n```{.r .cell-code}\ntriad.census(climate.net, mode = \"graph\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        0    1   2   3\n[1,] 3023 2016 787 158\n```\n:::\n\n```{.r .cell-code}\nclimate.nodes = data.frame(name = climate.net %v% \"vertex.names\", degree = degree(climate.net), indegree = degree(climate.net, cmode = \"indegree\"), outdegree = degree(climate.net, cmode = \"outdegree\"))\n```\n:::\n\n\n\n## Centrality\n\nCompute at least one measure of centrality for each node, adding them as attributes to `nodes` in the form of extra columns: eigencentrality, betweenness, closeness, etc. Compute the distribution of at least one of those measures. What do we learn from comparing these measures of centrality with an equivalent random network (i.e. with the same number of edges and vertices)?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclimate.nodes$bonpow <- bonpow(climate.net)\nsummary(climate.nodes$bonpow)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-2.97105 -0.93405 -0.05148 -0.29414  0.25824  1.45209 \n```\n:::\n\n```{.r .cell-code}\nset.seed(1)\nrandom.ig <- sample_gnm(34, 291, directed = TRUE)\nrandom.nodes <- data.frame(bonpow = power_centrality(random.ig))\nsummary(random.nodes$bonpow)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-2.01161 -0.78127 -0.10930 -0.07121  0.57926  2.01038 \n```\n:::\n:::\n\n\nThe Bonacich power centrality scores also emphasize the fact that there is long right tail when it comes to degree distribution. The random graph has a much more symmetric distribution. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}