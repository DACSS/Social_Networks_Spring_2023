{
  "hash": "222c484ba81dad0cd3a33c3b24b43366",
  "result": {
    "markdown": "---\ntitle: \"WK7Challenge_KDocekal\"\noutput: html_document\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(statnet)\nlibrary(gssr)\nlibrary(drat)\n\nknitr::opts_chunk$set(echo = TRUE)\n```\n:::\n\n\n\n\nMy dataset uses results from the 1985 General Social Survey. The 1985 GSS dataset is in edgelist format. There are 1534 observations with 622 variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"kjhealy/gssr\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSkipping install of 'gssr' from a github remote, the SHA1 (abe949b1) has not changed since last install.\n  Use `force = TRUE` to force installation\n```\n:::\n\n```{.r .cell-code}\ndrat::addRepo(\"kjhealy\")\n\ngss85 <- gss_get_yr(1985)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFetching: https://gss.norc.org/documents/stata/1985_stata.zip\n```\n:::\n\n```{.r .cell-code}\nhead(\ngss85)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 662\n  year     id wrkstat hrs1        hrs2        evwork      occ   prestige wrkslf \n  <dbl> <dbl> <dbl+l> <dbl+lbl>   <dbl+lbl>   <dbl+lbl>   <dbl> <dbl+lb> <dbl+l>\n1 1985      1 1 [wor…    40       NA(i) [iap] NA(i) [iap] 194   51       2 [som…\n2 1985      2 1 [wor…    65       NA(i) [iap] NA(i) [iap]  31   76       1 [sel…\n3 1985      3 2 [wor…     9       NA(i) [iap] NA(i) [iap] 180   51       2 [som…\n4 1985      4 3 [wit… NA(i) [iap]    60       NA(i) [iap]  65   82       2 [som…\n5 1985      5 1 [wor…    40       NA(i) [iap] NA(i) [iap] 915   20       2 [som…\n6 1985      6 1 [wor…    40       NA(i) [iap] NA(i) [iap] 185   46       1 [sel…\n# ℹ 653 more variables: wrkgovt <dbl+lbl>, industry <dbl+lbl>, found <dbl+lbl>,\n#   occ10 <dbl+lbl>, occindv <dbl+lbl>, occstatus <dbl+lbl>, occtag <dbl+lbl>,\n#   prestg10 <dbl+lbl>, prestg105plus <dbl+lbl>, indus10 <dbl+lbl>,\n#   indstatus <dbl+lbl>, indtag <dbl+lbl>, marital <dbl+lbl>, agewed <dbl+lbl>,\n#   divorce <dbl+lbl>, spwrksta <dbl+lbl>, sphrs1 <dbl+lbl>, sphrs2 <dbl+lbl>,\n#   spevwork <dbl+lbl>, spocc <dbl+lbl>, sppres <dbl+lbl>, spwrkslf <dbl+lbl>,\n#   spind <dbl+lbl>, spocc10 <dbl+lbl>, spoccindv <dbl+lbl>, …\n```\n:::\n\n```{.r .cell-code}\ndim(gss85)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1534  662\n```\n:::\n:::\n\n\nWe can first create the dataframe by selecting the ties variable. Here I use \"talkto\" which provides weighted edges based on members a respondent's group of contacts. Weights are based on respondents' perception of how much each contact talks to each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nties <- gss85[,grepl(\"talkto\", colnames(gss85))]\nhead(ties)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  talkto1             talkto2          talkto3          talkto4      talkto5    \n  <dbl+lbl>           <dbl+lbl>        <dbl+lbl>        <dbl+lbl>    <dbl+lbl>  \n1 2 [once a week]     1 [almost daily] 3 [once a month] 3 [once a m…     2 [onc…\n2 1 [almost daily]    2 [once a week]  1 [almost daily] 1 [almost d…     1 [alm…\n3 2 [once a week]     2 [once a week]  2 [once a week]  1 [almost d…     2 [onc…\n4 1 [almost daily]    1 [almost daily] 3 [once a month] 2 [once a w…     1 [alm…\n5 2 [once a week]     2 [once a week]  3 [once a month] 3 [once a m…     2 [onc…\n6 4 [lt once a month] 2 [once a week]  2 [once a week]  1 [almost d… NA(i) [iap]\n```\n:::\n:::\n\n\nA matrix and the igraph network can be created using the previous ties. There are 5 rows and columns corresponding to the number of respondent contacts, ties are undirected and weighted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat = matrix(nrow = 5, ncol = 5)\n\nmat[lower.tri(mat)] <- as.numeric(ties[3,])\n\nmat[upper.tri(mat)] = t(mat)[upper.tri(mat)]\n\nna_vals <- is.na(mat)\nnon_missing_rows <- rowSums(na_vals) < nrow(mat)\nmat <- mat[non_missing_rows,non_missing_rows]\n\ndiag(mat) <- 0\n\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    2    2    2    1\n[2,]    2    0    2    2    2\n[3,]    2    2    0    2    1\n[4,]    2    2    2    0    2\n[5,]    1    2    1    2    0\n```\n:::\n\n```{.r .cell-code}\nig.net <- graph.adjacency(mat, mode = \"undirected\", weighted = T)\n```\n:::\n\n\nEdges represent the weight between contacts. Contacts are numbered 1-5, based on participants' response order. For example, Edge 1--2 indicates that contacts number 1 and 2 talk to each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 20c2069 U-W- 5 10 -- \n+ attr: weight (e/n)\n+ edges from 20c2069:\n [1] 1--2 1--3 1--4 1--5 2--3 2--4 2--5 3--4 3--5 4--5\n```\n:::\n\n```{.r .cell-code}\nhead(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n              \n[1,] . 2 2 2 1\n[2,] 2 . 2 2 2\n[3,] 2 2 . 2 1\n[4,] 2 2 2 . 2\n[5,] 1 2 1 2 .\n```\n:::\n:::\n\n\nResults show that there is 1 component and the median weight is 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::components(ig.net)$no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nsummary(E(ig.net)$weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    1.0     2.0     2.0     1.8     2.0     2.0 \n```\n:::\n:::\n\n\nThis network contains 5 vertices and 10 edges. Ties are not bipartite or directed but they are weighted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvcount(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\necount(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nis_bipartite(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_directed(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_weighted(ig.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nAs an undirected graph we can use Fast and Greedy for community clustering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Run clustering algorithm: fast_greedy\ncomm.fg<-cluster_fast_greedy(ig.net)\n\n#Inspect clustering object\nnames(comm.fg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"merges\"     \"modularity\" \"membership\" \"algorithm\"  \"vcount\"    \n```\n:::\n:::\n\n\nThis identifies two groups; contact 3 and all other nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm.fg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH clustering fast greedy, groups: 2, mod: 2.8e-17\n+ groups:\n  $`1`\n  [1] 1 2 4 5\n  \n  $`2`\n  [1] 3\n  \n```\n:::\n:::\n\n\nExamining the community membership vector shows membership distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm.fg$membership\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 2 1 1\n```\n:::\n:::\n\n\nPlotting with coloring shows a visualization of these two communities.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(comm.fg,ig.net)\n```\n\n::: {.cell-output-display}\n![](wk7ChallengeKDocekal_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nWalktrap is another potential algorithm for community detection. \n\n::: {.cell}\n\n```{.r .cell-code}\ncomm.wt<-walktrap.community(ig.net)\n\n\nigraph::groups(comm.wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nTesting with steps ranging from 20 to 2000 all reveal the same, single community. \n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::groups(walktrap.community(ig.net ,steps=20))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nigraph::groups(walktrap.community(ig.net ,steps=200))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nigraph::groups(walktrap.community(ig.net ,steps=2000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nPlotting the network with Walktrap shows a single community with all nodes connected. The walktrap community makes the most sense as the more representative graph as we already know nodes are connected through their association with the respondent. In this case changing the number of steps does affect theses results and confirms our expectations. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(comm.wt,ig.net)\n```\n\n::: {.cell-output-display}\n![](wk7ChallengeKDocekal_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "wk7ChallengeKDocekal_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}