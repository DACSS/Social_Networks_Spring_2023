{
  "hash": "8386f61f400095327984fc3b064869a7",
  "result": {
    "markdown": "---\ntitle: \"Kruzlic Week 2 Challenge\"\nauthor: \"Bryn Kruzlic\"\ndescription: \"Basics of a Network: Dyads and Triads\"\ndate: \"03/06/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n# editor: visual\ncategories: \n  - challenge_2\n  - instructions\n  # - railroads\n  # - faostat\n  # - wildbirds\n---\n\n\n\n## Describe the Network Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.1.8\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(igraph)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'igraph'\n\nThe following objects are masked from 'package:lubridate':\n\n    %--%, union\n\nThe following objects are masked from 'package:dplyr':\n\n    as_data_frame, groups, union\n\nThe following objects are masked from 'package:purrr':\n\n    compose, simplify\n\nThe following object is masked from 'package:tidyr':\n\n    crossing\n\nThe following object is masked from 'package:tibble':\n\n    as_data_frame\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\nThe following object is masked from 'package:base':\n\n    union\n```\n:::\n\n```{.r .cell-code}\ngot_like_dislike <- read_csv(\"_data/got/got_like_dislike.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 46 Columns: 49\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): Current house, Former house, Name\ndbl (46): Lysa Arryn, Petyr Baelish, Joffrey Baratheon, Margaery Tyrell, Ren...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nView(got_like_dislike)\n```\n:::\n\n\n1. *List and inspect* List the objects to make sure the datafiles are working properly.\n2. *Network Size* What is the size of the network? You may use `vcount` and `ecount`.\n3. *Network features* Are these networks weighted, directed, and bipartite?\n4. *Network Attributes* Now, using commands from either `statnet` or `igraph`, list the vertex and edge attributes.\n\n#### First, we can list the object by using the command 'ls' to make suret the proper data is coming through. \n\n::: {.cell}\n\n```{.r .cell-code}\nls(got_like_dislike)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Arya Stark\"            \"Balon Greyjoy\"         \"Bran Stark\"           \n [4] \"Brienne of Tarth\"      \"Bronn\"                 \"Catelyn Stark\"        \n [7] \"Cersei Lannister\"      \"Current house\"         \"Daenerys Targaryen\"   \n[10] \"Davos Seaworth\"        \"Eddard Stark\"          \"Former house\"         \n[13] \"Gendry\"                \"Grand Maester Pycelle\" \"Gregor Clegane\"       \n[16] \"Hodor\"                 \"Jaime Lannister\"       \"Jaqen H'ghar\"         \n[19] \"Jeor Mormont\"          \"Joffrey Baratheon\"     \"Jon Snow\"             \n[22] \"Jorah Mormont\"         \"Khal Drogo\"            \"Lancel Lannister\"     \n[25] \"Loras Tyrell\"          \"Lysa Arryn\"            \"Maester Luwin\"        \n[28] \"Margaery Tyrell\"       \"Melisandre\"            \"Name\"                 \n[31] \"Osha\"                  \"Petyr Baelish\"         \"Podrick Payne\"        \n[34] \"Pyat Pree\"             \"Renly Baratheon\"       \"Robb Stark\"           \n[37] \"Robert Baratheon\"      \"Ros\"                   \"Samwell Tarly\"        \n[40] \"Sandor Clegane\"        \"Sansa Stark\"           \"Shae\"                 \n[43] \"Stannis Baratheon\"     \"Theon Greyjoy\"         \"Tyrion Lannister\"     \n[46] \"Tywin Lannister\"       \"Varys\"                 \"Viserys Targaryen\"    \n[49] \"Xaro Xhoan Daxos\"     \n```\n:::\n:::\n\n#### Network size can be determined with the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_like_dislike.ig <- graph_from_data_frame(got_like_dislike)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in graph_from_data_frame(got_like_dislike): In `d' `NA' elements were\nreplaced with string \"NA\"\n```\n:::\n\n```{.r .cell-code}\nvcount(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\necount(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 46\n```\n:::\n:::\n\n#### Currently, we can see there are 11 vertices with 46 edges. \n\n#### We can determine the network features, discussed in Challenge 1, with the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.bipartite(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.directed(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.weighted(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n#### While the network is not bipartite or weighted, it is directed. Since we know that we will be discussing triads later on, it is important to determine and make sure that our network is directed. Undirected graphs will have no asymmetric edges. \n\n### The network attributes can be found here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::vertex_attr_names(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nigraph::edge_attr_names(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Name\"                  \"Lysa Arryn\"            \"Petyr Baelish\"        \n [4] \"Joffrey Baratheon\"     \"Margaery Tyrell\"       \"Renly Baratheon\"      \n [7] \"Robert Baratheon\"      \"Stannis Baratheon\"     \"Brienne of Tarth\"     \n[10] \"Bronn\"                 \"Gregor Clegane\"        \"Sandor Clegane\"       \n[13] \"Xaro Xhoan Daxos\"      \"Gendry\"                \"Balon Greyjoy\"        \n[16] \"Theon Greyjoy\"         \"Jaqen H'ghar\"          \"Hodor\"                \n[19] \"Khal Drogo\"            \"Cersei Lannister\"      \"Jaime Lannister\"      \n[22] \"Lancel Lannister\"      \"Tyrion Lannister\"      \"Tywin Lannister\"      \n[25] \"Maester Luwin\"         \"Melisandre\"            \"Jeor Mormont\"         \n[28] \"Jorah Mormont\"         \"Osha\"                  \"Podrick Payne\"        \n[31] \"Pyat Pree\"             \"Grand Maester Pycelle\" \"Ros\"                  \n[34] \"Davos Seaworth\"        \"Shae\"                  \"Jon Snow\"             \n[37] \"Arya Stark\"            \"Bran Stark\"            \"Catelyn Stark\"        \n[40] \"Robb Stark\"            \"Sansa Stark\"           \"Daenerys Targaryen\"   \n[43] \"Viserys Targaryen\"     \"Samwell Tarly\"         \"Loras Tyrell\"         \n[46] \"Varys\"                 \"Eddard Stark\"         \n```\n:::\n:::\n\n\n## Dyad and Triad Census\n\n### *Dyad Census:*\n\n#### Three key components of a dyad census involve determining the relationships. In this case, we can observe the relationships by using the functions- reciprocal or 'mut', asymmetric or 'asym' and finally, absent or 'null'. We can determine the answers by the following: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::dyad.census(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 1\n\n$asym\n[1] 12\n\n$null\n[1] 42\n```\n:::\n:::\n\n#### Since this is a directed graph, we can see the listings of reciprocal dyads (being 1), asymmetric dyads (being 12) and absent dyads (being 42). \n\n### *Triad Census:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::triad.census(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 83 32 18  1 22  1  5  0  1  0  0  2  0  0  0  0\n```\n:::\n:::\n\n\n## Global and Local Transitivity Clustering\n\n#### Transitivity here refers to the probability that the vertices will be connected in a given network. In this case, we can determine the local transitivity and global transitivity with the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransitivity(got_like_dislike.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2368421\n```\n:::\n\n```{.r .cell-code}\ntransitivity(got_like_dislike.ig, type = 'global')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2368421\n```\n:::\n\n```{.r .cell-code}\ntransitivity(got_like_dislike.ig, type = 'average') \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5867347\n```\n:::\n:::\n\n*I have realized in my efforts that the standard transitivity() command automatically defaults to global.* \n\n#### We can round this up to 0.24, representing that almost 25% of the global triads are transitive, while 59% of the local triads are transitive. This local transivity can be called the average clustering coefficient, focusing on the low degree nodes of the network. \n\n## Path Length and Component Structure\n\n#### One can determine the path length and diameter by the following\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage.path.length(got_like_dislike.ig,directed = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.3\n```\n:::\n\n```{.r .cell-code}\nigraph::components(got_like_dislike.ig)$no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nigraph::components(got_like_dislike.ig)$csize\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n#### As shown above, the average path length appears to be 1.3 with 1 component at a size of 11.  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}