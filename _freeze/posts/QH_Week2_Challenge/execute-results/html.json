{
  "hash": "1956ff8ba3fbc42457eb4855c112f17c",
  "result": {
    "markdown": "---\ntitle: \"Week 2 Challenge\"\nauthor: \"Quinn He\"\ndescription: \"Describing the Basic Structure of a Network\"\ndate: \"03/02/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\n# editor: visual\ncategories: \n  - challenge_2\n  - instructions\n  - got_marriages\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarriages <- read_csv(\"../posts/_data/got/got_marriages.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 255 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): From, To, Type, Notes, Generation\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nI am not sure exactly how to read in a csv into a statnet object. I saw Ben used this kind of format so I used this one for now, but further in the challenge I hit some errors I have not yet figured out how to resolve that may have stemmed from this read in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot.ig <- graph_from_data_frame(marriages, directed = F)\ngot.net <- as.network.data.frame(marriages, directed = F, loops = T, multiple = T)\n```\n:::\n\n\n\n## Challenge Overview\n\n\nIdentify and describe content of nodes and links, and identify format of data set (i.e., matrix or edgelist, directed or not, weighted or not), and whether attribute data are present. Be sure to provide information about network size (e.g., information obtained from network description using week 1 network basic tutorial commands.)\n\nExplore the dataset using commands from week 2 tutorial. Comment on the highlighted aspects of network structure such as: \n\n- Geodesic and Path Distances; Path Length\n- Dyads and Dyad Census\n- Triads and Triad Census\n- Network Transitivity and Clustering\n- Component Structure and Membership\n\nBe sure to both provide the relevant statistics calculated in `R`, as well as your own interpretation of these statistics.\n\n## Describe the Network Data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls(got.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"gal\" \"iel\" \"mel\" \"oel\" \"val\"\n```\n:::\n\n```{.r .cell-code}\n#ls(got.ig)#Ill revisit that later. This is indicating that the data files are not working properly, but I can run the code\n#just fine down below. \n```\n:::\n\n\nBased on the output by statnet, this network has 20 vertices/actors in the network and there are 255 total edges/connections between those actors. I have included loops so this data set can contain marriages within the same family. It is an undirected network, meaning there is a mutual connection, shared connection; information flows both ways.\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(got.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 20 \n  directed = FALSE \n  hyper = FALSE \n  loops = TRUE \n  multiple = TRUE \n  bipartite = FALSE \n  total edges= 255 \n    missing edges= 0 \n    non-missing edges= 255 \n\n Vertex attribute names: \n    vertex.names \n\n Edge attribute names: \n    Generation Notes Type \n```\n:::\n:::\n\n\n\nLet's see if igraph gives the same results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvcount(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\necount(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 255\n```\n:::\n:::\n\nThe vertices and edge counts are the same as the statnet output. I can also see with igraph that the network is unweighted meaning there are not \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_weighted(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_bipartite(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_directed(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_attr_names(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nedge_attr_names(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Type\"       \"Notes\"      \"Generation\"\n```\n:::\n:::\n\n\n\n\n1. *List and inspect* List the objects to make sure the datafiles are working properly.\n2. *Network Size* What is the size of the network? You may use `vcount` and `ecount`.\n3. *Network features* Are these networks weighted, directed, and bipartite?\n4. *Network Attributes* Now, using commands from either `statnet` or `igraph`, list the vertex and edge attributes.\n\n## Dyad and Triad Census\n\nHere I will look at the number of dyad (total number of 2 connections) and triad (total number of triangle connections). Now igraph and statnet give two different outputs for dyad census. \n\nAccording to igraph, there are 60 mutual connections, 0 non-mutual connections, and 130 absent connections. \n\n::: {.cell}\n\n```{.r .cell-code}\ndyad_census(got.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 60\n\n$asym\n[1] 0\n\n$null\n[1] 130\n```\n:::\n:::\n\n\n\nStatnet observes 310 mutual connections with, somehow, -250 asymmetric connections, and the same number of null.  connections. Why would there be a set of negative connections? \n\n::: {.cell}\n\n```{.r .cell-code}\nsna::dyad.census(got.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Mut Asym Null\n[1,] 310 -250  130\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntriad.census(got.ig)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in triad.census(got.ig): At core/misc/motifs.c:1165 : Triad census\ncalled on an undirected graph.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 625   0 227   0   0   0   0   0   0   0 228   0   0   0   0  60\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsna::triad.census(got.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     003 012 102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210 300\n[1,] 408   0 444    0    0    0    0    0    0    0 228    0    0    0   0  60\n```\n:::\n:::\n\n\nThe statnet output is much easier to read and gives a clearer view of what types of triads are throughout the network. It's handy because it lists all 16 of the unique combinations in directed ties. I much prefer this over igraphs interpretation of triad census. \n\n003 means there are 3 null dyads and no mutual or asymmetric, so there are 408 of those types. 102 means there are 444 triads with 1 mutual connection. 201 is there are 2 mutual connections in 228 triads. There are 60 complete triads. For example, there are 60 instances of 3 families marrying around. \n\n## Global and Local Transitivity or Clustering\n\nCompute global transitivity using `transitivity` on `igraph` or `gtrans` on `statnet` and local transitivity of specific nodes of your choice, in addition to the average clustering coefficient. What is the distribution of node degree and how does it compare with the distribution of local transitivity?\n\nRemember! All three nodes have to be connected to be considered part of the transitive calculation in statnet.\n\nThe number I get will be the measure of the portion of connected triads in the network that are complete. A 1 would mean all connected triads are transitive. \n\nThe average local clustering is about 10% higher than the global clustering coefficient. This means that there is a 54% chance that friends of the ego are likely to know each other. It is the density of ties between neighbors. Each ego has a local clustering coefficient, the 54% is just the average. \n\n44% of the triads in the network are complete triads. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransitivity(got.ig, type = \"average\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5478074\n```\n:::\n\n```{.r .cell-code}\ntransitivity(got.ig, type = \"global\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4411765\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngtrans(got.net, diag = T)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.matrix.network.adjacency(x, attrname = attrname, expand.bipartite = expand.bipartite, : Multigraphs not currently supported in as.matrix.network.adjacency.  Exiting.\n```\n:::\n:::\n\n\n\n\n\n\n## Path Length and Component Structure \n\nCan you compute the average path length and the _diameter_ of the network? Can you find the component structure of the network and identify the cluster membership of each node?\n\nThe average path length between two nodes is 1.9, which indicates to me that many of the nodes are relatively close together. The diameter measure shows the length of the longest geodesic distance between nodes. 4 does not seem to be too high but I am not sure what to compare it to. \n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage.path.length(got.ig, directed = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.9\n```\n:::\n\n```{.r .cell-code}\ndiameter(got.ig, directed = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n\n\nFrom this we can see there is a single component. \n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::components(got.ig)$no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nThe one component has only 20 members in it with no isolates so all the nodes are connected. If this is true the next command should confirm there are no isolates and return a 0\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::components(got.ig)$csize\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\nNice!\n\n::: {.cell}\n\n```{.r .cell-code}\nisolates(got.net)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n",
    "supporting": [
      "QH_Week2_Challenge_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}