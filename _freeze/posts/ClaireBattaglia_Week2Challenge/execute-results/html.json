{
  "hash": "e557083d799c0b43ddf03586cd3f5740",
  "result": {
    "markdown": "---\ntitle: \"Week 2 Challenge\"\nauthor: \"Claire Battaglia\"\ndesription: \"Describing the basic structure of a network\"\ndate: \"March 1, 2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - Claire Battaglia\n  - challenge2\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(statnet)\n\nknitr::opts_chunk$set(echo = TRUE)\n```\n:::\n\n\n## Describe the network data\n\nThis week I'll be creating a network of the distances between various places in Game of Thrones. The data are organized in an edgelist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in data\ndist <- read_csv(\"_data/got/got_distances.csv\", show_col_types = FALSE)\n\n# reorder columns\ndist <- dist %>%\n    relocate(From, To, Miles, Mode, .before = \"Region From\")\n\n# preview\nhead(dist, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 6\n   From          To               Miles Mode  `Region From` Notes   \n   <chr>         <chr>            <dbl> <chr> <chr>         <chr>   \n 1 Casterly Rock the Golden Tooth   240 land  Westerlands   <NA>    \n 2 Casterly Rock Lannisport          40 land  Westerlands   <NA>    \n 3 Casterly Rock Kayce              100 land  Westerlands   <NA>    \n 4 Casterly Rock Kayce               12 water Westerlands   <NA>    \n 5 Casterly Rock Deep Den           240 land  Westerlands   Goldroad\n 6 Deep Den      King’s Landing     590 land  Westerlands   Goldroad\n 7 Kayce         Faircastle         480 raven Westerlands   <NA>    \n 8 Faircastle    the Crag           115 Boat  Westerlands   Island  \n 9 the Crag      Ashemark            85 land  Westerlands   <NA>    \n10 Ashemark      Casterly Rock      170 land  Westerlands   <NA>    \n```\n:::\n:::\n\n\nThe \"from\" and \"to\" fields are already clearly defined and it seems as though the miles and mode are edge attributes. I'm not sure what the \"Region From\" field is in the context of a network, though.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create network object\ndist.ig <- graph_from_data_frame(dist, directed = FALSE)\n\n# view\nprint(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 0440fcf UN-- 134 200 -- \n+ attr: name (v/c), Miles (e/n), Mode (e/c), Region From (e/c), Notes\n| (e/c)\n+ edges from 0440fcf (vertex names):\n [1] Casterly Rock--the Golden Tooth Casterly Rock--Lannisport      \n [3] Casterly Rock--Kayce            Casterly Rock--Kayce           \n [5] Casterly Rock--Deep Den         Deep Den     --King’s Landing  \n [7] Kayce        --Faircastle       Faircastle   --the Crag        \n [9] the Crag     --Ashemark         Casterly Rock--Ashemark        \n[11] Ashemark     --the Golden Tooth Lannisport   --Crakehall       \n[13] Crakehall    --Old Oak          Old Oak      --Highgarden      \n+ ... omitted several edges\n```\n:::\n:::\n\n\nWe can see a few things from this summary:\n\n1. The network is **undirected**. This makes sense as distances between physical locations are by nature symmetrical.\n1. The network is **named**. I.e. the nodes/vertices have names. In this network the nodes are physical places with names.\n1. The edges are **unweighted**.\n1. It is not bipartite.\n1. There are 134 nodes/vertices.\n1. There are 200 edges/ties.\n\nWe can get a bit more information about the nodes and edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get count\nvcount(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 134\n```\n:::\n\n```{.r .cell-code}\necount(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 200\n```\n:::\n\n```{.r .cell-code}\n# get attributes\nvertex_attr_names(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"name\"\n```\n:::\n\n```{.r .cell-code}\nedge_attr_names(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Miles\"       \"Mode\"        \"Region From\" \"Notes\"      \n```\n:::\n:::\n\n\nThe \"Region From\" field is currently being understood as an edge attribute, which doesn't really make sense to me so I am wondering if I need to specify it as something else.\n\n## Dyad and triad census\n\nWe can also use a dyad and triad census to get a better understanding of the network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dyad census\nigraph::dyad.census(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mut\n[1] 190\n\n$asym\n[1] 0\n\n$null\n[1] 8721\n```\n:::\n:::\n\nI'm not sure what to make of the dyad census. Given that distances between places are by nature reciprocal, I don't understand why all the dyads aren't mutual. There is no way for Casterly Rock to be 240 miles from the Golden Tooth without the Golden Tooth also being 240 miles from Casterly Rock.\n\nGiven the number of null dyads (i.e. missing ties), it seems as though the mileage between many places hasn't been recorded. Again, there is by definition a distance between any two physical places.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# triad census\nigraph::triad.census(dist.ig)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in igraph::triad.census(dist.ig): At core/misc/motifs.c:1165 : Triad\ncensus called on an undirected graph.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 368822      0  22731      0      0      0      0      0      0      0\n[11]    501      0      0      0      0     30\n```\n:::\n:::\n\n\nA triad census doesn't work on an undirected grapgh so I'm not sure whether there is anything meaningful here.\n\nLogically we know there is a distance between every two physical place so it seems like the dyad and triad census in this case is more useful for revealing missing distances than anything else.\n\nIf the ties in this network were roads or established routes of some kind, both censuses could reveal interesting insight into places that are more connected than others but distance is a feature of the physical world, not a human creation.\n\n## Global and local transitivity\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get global trans\ntransitivity(dist.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1522843\n```\n:::\n\n```{.r .cell-code}\n# get avg local trans\ntransitivity(dist.ig, type = \"average\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1767116\n```\n:::\n\n```{.r .cell-code}\n# get local trans of Winterfell, Casterly Rock\ntransitivity(dist.ig, type = \"local\", vids = V(dist.ig)[c(\"Winterfell\", \"Casterly Rock\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.03571429 0.09523810\n```\n:::\n:::\n\n\nWe can see that the transitivity scores of Winterfell and Casterly Rock are .04 and .1, respectively, indicating that in the context of this network, a higher percentage of the nodes connected to Casterly Rock are also connected to each other than for Winterfell.\n\nAgain, the concept of transitivity doesn't make a lot of sense when we're talking about distances between physical features.\n\n## Path length and component structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get component names\nnames(igraph::components(dist.ig))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"membership\" \"csize\"      \"no\"        \n```\n:::\n\n```{.r .cell-code}\n# get number of components\nigraph::components(dist.ig)$no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n# get size of components\nigraph::components(dist.ig)$csize\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 129   3   2\n```\n:::\n:::\n\n\nThis is interesting. There are three components in the network. If the network included the distances between each of the places included---as in a map---there would be just a single component in the network. Either the network is missing a lot of information or I read it in incorrectly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get distance between Winterfell and Casterly Rock\ndistances(dist.ig,\"Winterfell\",\"Casterly Rock\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Casterly Rock\nWinterfell             2\n```\n:::\n\n```{.r .cell-code}\n# get distance between Winterfell and King’s Landing\ndistances(dist.ig,\"Winterfell\",\"King’s Landing\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           King’s Landing\nWinterfell              1\n```\n:::\n\n```{.r .cell-code}\n# get distance between Casterly Rock and King’s Landing\ndistances(dist.ig,\"King’s Landing\",\"Casterly Rock\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               Casterly Rock\nKing’s Landing             1\n```\n:::\n:::\n\nBoth Winterfell and Casterly Rock are equidistant from King's Landing. We know this isn't true in terms of the number of miles so I think this is talking about the number of nodes in between each of them and King's Landing. This is interesting because even this measure of distance (i.e. number of nodes instead of number of miles) can have profound socio-political implications.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get density\ngraph.density(dist.ig, loops = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.02211166\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove multiple and loops\ndist.ig <- simplify(dist.ig, remove.multiple = F, remove.loops = T)\n\n# assign weight??\n#E(dist.ig)$weight <- E(dist.ig)$Miles\n\n# plot network\nplot(dist.ig,\n     vertex.size = 5,\n     vertex.color = \"maroon\",\n     vertex.label.cex = .5,\n     main = \"Distances between places in Game of Thrones\")\n```\n\n::: {.cell-output-display}\n![](ClaireBattaglia_Week2Challenge_files/figure-html/plot-1.png){width=672}\n:::\n:::\n\n\n## Questions\n\n1. What to do with \"Region From\" field? This is potentially meaningful information but I'm not sure how to incorporate it into the network.\n1. How to make the length of the tie proportional to the number of miles? I'd like the `distance()` function to return the number of miles between two nodes--is this possible?\n1. How to display the number of miles?\n1. How to color the edges according to the mode?\n",
    "supporting": [
      "ClaireBattaglia_Week2Challenge_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}